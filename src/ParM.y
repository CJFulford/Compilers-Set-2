-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module ParM where
import AbsM
import LexM
import ErrM

}

%name pProg Prog
%name pBlock Block
%name pDeclarations Declarations
%name pDeclaration Declaration
%name pVar_declaration Var_declaration
%name pVar_specs Var_specs
%name pMore_var_specs More_var_specs
%name pVar_spec Var_spec
%name pArray_dimensions Array_dimensions
%name pType Type
%name pFun_declaration Fun_declaration
%name pFun_block Fun_block
%name pParam_list Param_list
%name pParameters Parameters
%name pMore_parameters More_parameters
%name pBasic_declaration Basic_declaration
%name pBasic_array_dimensions Basic_array_dimensions
%name pData_declaration Data_declaration
%name pCons_declarations Cons_declarations
%name pMore_cons_decl More_cons_decl
%name pCons_decl Cons_decl
%name pType_list Type_list
%name pMore_type More_type
%name pProgram_body Program_body
%name pFun_body Fun_body
%name pProg_stmts Prog_stmts
%name pProg_stmt Prog_stmt
%name pLocation Location
%name pCase_list Case_list
%name pMore_case More_case
%name pCase Case
%name pVar_list Var_list
%name pVar_list1 Var_list1
%name pMore_var_list More_var_list
%name pExpr Expr
%name pBint_term Bint_term
%name pBint_factor Bint_factor
%name pCompare_op Compare_op
%name pInt_expr Int_expr
%name pAddop Addop
%name pInt_term Int_term
%name pMulop Mulop
%name pInt_factor Int_factor
%name pModifier_list Modifier_list
%name pFun_argument_list Fun_argument_list
%name pCons_argument_list Cons_argument_list
%name pArguments Arguments
%name pMore_arguments More_arguments
-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype {Token}
%token
  '&&' { PT _ (TS _ 1) }
  '(' { PT _ (TS _ 2) }
  ')' { PT _ (TS _ 3) }
  '*' { PT _ (TS _ 4) }
  '+' { PT _ (TS _ 5) }
  ',' { PT _ (TS _ 6) }
  '-' { PT _ (TS _ 7) }
  '/' { PT _ (TS _ 8) }
  ':' { PT _ (TS _ 9) }
  ':=' { PT _ (TS _ 10) }
  ';' { PT _ (TS _ 11) }
  '<' { PT _ (TS _ 12) }
  '=' { PT _ (TS _ 13) }
  '=<' { PT _ (TS _ 14) }
  '=>' { PT _ (TS _ 15) }
  '>' { PT _ (TS _ 16) }
  '>=' { PT _ (TS _ 17) }
  '[' { PT _ (TS _ 18) }
  ']' { PT _ (TS _ 19) }
  'begin' { PT _ (TS _ 20) }
  'bool' { PT _ (TS _ 21) }
  'case' { PT _ (TS _ 22) }
  'ceil' { PT _ (TS _ 23) }
  'char' { PT _ (TS _ 24) }
  'data' { PT _ (TS _ 25) }
  'do' { PT _ (TS _ 26) }
  'else' { PT _ (TS _ 27) }
  'end' { PT _ (TS _ 28) }
  'false' { PT _ (TS _ 29) }
  'float' { PT _ (TS _ 30) }
  'floor' { PT _ (TS _ 31) }
  'fun' { PT _ (TS _ 32) }
  'if' { PT _ (TS _ 33) }
  'int' { PT _ (TS _ 34) }
  'not' { PT _ (TS _ 35) }
  'of' { PT _ (TS _ 36) }
  'print' { PT _ (TS _ 37) }
  'read' { PT _ (TS _ 38) }
  'real' { PT _ (TS _ 39) }
  'return' { PT _ (TS _ 40) }
  'size' { PT _ (TS _ 41) }
  'then' { PT _ (TS _ 42) }
  'true' { PT _ (TS _ 43) }
  'var' { PT _ (TS _ 44) }
  'while' { PT _ (TS _ 45) }
  '{' { PT _ (TS _ 46) }
  '|' { PT _ (TS _ 47) }
  '||' { PT _ (TS _ 48) }
  '}' { PT _ (TS _ 49) }

L_integ  { PT _ (TI $$) }
L_doubl  { PT _ (TD $$) }
L_charac { PT _ (TC $$) }
L_CID { PT _ (T_CID $$) }
L_ID { PT _ (T_ID $$) }


%%

Integer :: { Integer } : L_integ  { (read ( $1)) :: Integer }
Double  :: { Double }  : L_doubl  { (read ( $1)) :: Double }
Char    :: { Char }    : L_charac { (read ( $1)) :: Char }
CID    :: { CID} : L_CID { CID ($1)}
ID    :: { ID} : L_ID { ID ($1)}

Prog :: { Prog }
Prog : Block { AbsM.Prg $1 }
Block :: { Block }
Block : Declarations Program_body { AbsM.Blok $1 $2 }
Declarations :: { Declarations }
Declarations : Declaration ';' Declarations { AbsM.Dec $1 $3 }
             | {- empty -} { AbsM.DecN }
Declaration :: { Declaration }
Declaration : Var_declaration { AbsM.DecV $1 }
            | Fun_declaration { AbsM.DecF $1 }
            | Data_declaration { AbsM.DecD $1 }
Var_declaration :: { Var_declaration }
Var_declaration : 'var' Var_specs ':' Type { AbsM.VarD $2 $4 }
Var_specs :: { Var_specs }
Var_specs : Var_spec More_var_specs { AbsM.VarS $1 $2 }
More_var_specs :: { More_var_specs }
More_var_specs : ',' Var_spec More_var_specs { AbsM.MVarS $2 $3 }
               | {- empty -} { AbsM.MVar }
Var_spec :: { Var_spec }
Var_spec : Array_dimensions { AbsM.VarSp $1 }
Array_dimensions :: { Array_dimensions }
Array_dimensions : '[' Expr ']' Array_dimensions { AbsM.ArrDi $2 $4 }
                 | {- empty -} { AbsM.ArrD }
Type :: { Type }
Type : 'int' { AbsM.TInt }
     | 'real' { AbsM.TRea }
     | 'bool' { AbsM.TBoo }
     | 'char' { AbsM.TCha }
     | ID { AbsM.Tid $1 }
Fun_declaration :: { Fun_declaration }
Fun_declaration : 'fun' ID Param_list ':' Type '{' Fun_block '}' { AbsM.FunD $2 $3 $5 $7 }
Fun_block :: { Fun_block }
Fun_block : Declarations Fun_body { AbsM.FunB $1 $2 }
Param_list :: { Param_list }
Param_list : '(' Parameters ')' { AbsM.ParL $2 }
Parameters :: { Parameters }
Parameters : Basic_declaration More_parameters { AbsM.Para $1 $2 }
           | {- empty -} { AbsM.ParaN }
More_parameters :: { More_parameters }
More_parameters : ',' Basic_declaration More_parameters { AbsM.MPar $2 $3 }
                | {- empty -} { AbsM.MParN }
Basic_declaration :: { Basic_declaration }
Basic_declaration : ID Basic_array_dimensions ':' Type { AbsM.BDec $1 $2 $4 }
Basic_array_dimensions :: { Basic_array_dimensions }
Basic_array_dimensions : '[' ']' Basic_array_dimensions { AbsM.BArrD $3 }
                       | {- empty -} { AbsM.BArrN }
Data_declaration :: { Data_declaration }
Data_declaration : 'data' ID ':=' Cons_declarations { AbsM.DatDec $2 $4 }
Cons_declarations :: { Cons_declarations }
Cons_declarations : Cons_decl More_cons_decl { AbsM.ConDec $1 $2 }
More_cons_decl :: { More_cons_decl }
More_cons_decl : '|' Cons_decl More_cons_decl { AbsM.MConDc $2 $3 }
               | {- empty -} { AbsM.MConNl }
Cons_decl :: { Cons_decl }
Cons_decl : CID 'of' Type_list { AbsM.CnDecl $1 $3 }
          | CID { AbsM.CnDec $1 }
Type_list :: { Type_list }
Type_list : Type More_type { AbsM.TpeLst $1 $2 }
More_type :: { More_type }
More_type : '*' Type More_type { AbsM.MreTyp $2 $3 }
          | {- empty -} { AbsM.MrTypN }
Program_body :: { Program_body }
Program_body : 'begin' Prog_stmts 'end' { AbsM.PrgBdy $2 }
             | Prog_stmts { AbsM.PrgBd $1 }
Fun_body :: { Fun_body }
Fun_body : 'begin' Prog_stmts 'return' Expr ';' 'end' { AbsM.FunBdy $2 $4 }
         | Prog_stmts 'return' Expr ';' { AbsM.FunBd $1 $3 }
Prog_stmts :: { Prog_stmts }
Prog_stmts : Prog_stmt ';' Prog_stmts { AbsM.PrgStm $1 $3 }
           | {- empty -} { AbsM.PrgSt }
Prog_stmt :: { Prog_stmt }
Prog_stmt : 'if' Expr 'then' Prog_stmt 'else' Prog_stmt { AbsM.ProgIf $2 $4 $6 }
          | 'while' Expr 'do' Prog_stmt { AbsM.ProgWh $2 $4 }
          | 'read' Location { AbsM.ProgRd $2 }
          | Location ':=' Expr { AbsM.ProgAs $1 $3 }
          | 'print' Expr { AbsM.ProgPt $2 }
          | '{' Block '}' { AbsM.ProgBl $2 }
          | 'case' Expr 'of' '{' Case_list '}' { AbsM.ProgCs $2 $5 }
Location :: { Location }
Location : ID Array_dimensions { AbsM.Loca $1 $2 }
Case_list :: { Case_list }
Case_list : Case More_case { AbsM.CseLst $1 $2 }
More_case :: { More_case }
More_case : '|' Case More_case { AbsM.MrCase $2 $3 }
          | {- empty -} { AbsM.MrCasN }
Case :: { Case }
Case : CID Var_list '=>' Prog_stmt { AbsM.Cas $1 $2 $4 }
Var_list :: { Var_list }
Var_list : '(' Var_list1 ')' { AbsM.VarLst $2 }
         | {- empty -} { AbsM.VarLstN }
Var_list1 :: { Var_list }
Var_list1 : ID More_var_list { AbsM.VarLst1 $1 $2 }
More_var_list :: { More_var_list }
More_var_list : ',' ID More_var_list { AbsM.MVrLst $2 $3 }
              | {- empty -} { AbsM.MVrLtN }
Expr :: { Expr }
Expr : Expr '||' Bint_term { AbsM.ExprE $1 $3 }
     | Bint_term { AbsM.ExprB $1 }
Bint_term :: { Bint_term }
Bint_term : Bint_term '&&' Bint_factor { AbsM.BIntTrm $1 $3 }
          | Bint_factor { AbsM.BIntTmF $1 }
Bint_factor :: { Bint_factor }
Bint_factor : 'not' Bint_factor { AbsM.BIntFac $2 }
            | Int_expr Compare_op Int_expr { AbsM.BIntFCm $1 $2 $3 }
            | Int_expr { AbsM.BIntFcI $1 }
Compare_op :: { Compare_op }
Compare_op : '=' { AbsM.CmpOpEq }
           | '<' { AbsM.CmpOpLT }
           | '>' { AbsM.CmpOpGT }
           | '=<' { AbsM.CmpOpLE }
           | '>=' { AbsM.CmpOpGE }
Int_expr :: { Int_expr }
Int_expr : Int_expr Addop Int_term { AbsM.IntExpE $1 $2 $3 }
         | Int_term { AbsM.IntExpT $1 }
Addop :: { Addop }
Addop : '+' { AbsM.AddOp } | '-' { AbsM.SubOp }
Int_term :: { Int_term }
Int_term : Int_term Mulop Int_factor { AbsM.IntTrmT $1 $2 $3 }
         | Int_factor { AbsM.IntTrmF $1 }
Mulop :: { Mulop }
Mulop : '*' { AbsM.MulOp } | '/' { AbsM.DivOp }
Int_factor :: { Int_factor }
Int_factor : '(' Expr ')' { AbsM.ItFcLPr $2 }
           | 'size' '(' ID Basic_array_dimensions ')' { AbsM.ItFcSiz $3 $4 }
           | 'float' '(' Expr ')' { AbsM.ItFcFlt $3 }
           | 'floor' '(' Expr ')' { AbsM.ItFcFlr $3 }
           | 'ceil' '(' Expr ')' { AbsM.ItFcCil $3 }
           | ID Modifier_list { AbsM.ItFcID $1 $2 }
           | Cons_argument_list { AbsM.ItFcCID $1 }
           | Integer { AbsM.ItFcIVl $1 }
           | Double { AbsM.ItFcRVl $1 }
           | 'true' { AbsM.ItFcBVT }
           | 'false' { AbsM.ItFcBVF }
           | Char { AbsM.ItFcCVl $1 }
           | '-' Int_factor { AbsM.ItFcSub $2 }
Modifier_list :: { Modifier_list }
Modifier_list : Fun_argument_list { AbsM.ModLstF $1 }
              | Array_dimensions { AbsM.ModLstA $1 }
Fun_argument_list :: { Fun_argument_list }
Fun_argument_list : '(' Arguments ')' { AbsM.FArgLst $2 }
Cons_argument_list :: { Cons_argument_list }
Cons_argument_list : Fun_argument_list { AbsM.CAgLstF $1 }
                   | {- empty -} { AbsM.CAgLstN }
Arguments :: { Arguments }
Arguments : Expr More_arguments { AbsM.Args $1 $2 }
          | {- empty -} { AbsM.ArgsN }
More_arguments :: { More_arguments }
More_arguments : ',' Expr More_arguments { AbsM.MArgs $2 $3 }
               | {- empty -} { AbsM.MArgsN }
{

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++ 
  case ts of
    [] -> []
    [Err _] -> " due to lexer error"
    _ -> " before " ++ unwords (map (id . prToken) (take 4 ts))

myLexer = tokens
}

